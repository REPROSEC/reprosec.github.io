@article{Dolev-Yao-1983,
author = {Danny Dolev and Andrew Chi{-}Chih Yao},
title = {{On the Security of Public Key Protocols}},
journal = {{IEEE Trans. Inf. Theor.}},
year = {1983},
volume = {29},
number = {2},
pages = {198--208},
}


@article{Needham-Schroeder-CACM-1978,
author = {Needham, Roger M. and Schroeder, Michael D.},
title = {{Using Encryption for Authentication in Large Networks of Computers}},
year = 1978,
volume = {21},
number = {12},
journal = {Communications of the ACM},
month = dec,
pages = {993--999},
}


@inproceedings{Lowe-TACAS-1996,
author = {Lowe, Gavin},
title = {{Breaking and Fixing the Needham-Schroeder Public-Key Protocol Using FDR}},
year = 1996,
booktitle = {TACAS},
pages = {147--166},
}

@article{Lowe-IPL-1995,
 author = {Gavin Lowe},
 journal = {{Inf. Process. Lett.}},
 number = {3},
 pages = {131--133},
 title = {{An Attack on the Needham-Schroeder Public-Key Authentication Protocol}},
 volume = {56},
 year = {1995}
}



@article{guttmanfest2021,
  ourwork =	 {yes},
  author =	 {Karthikeyan Bhargavan and Abhishek Bichhawat and
                  Quoc Huy Do and Pedram Hosseyni and Ralf Küsters and
                  Guido Schmitz and Tim Würtele},
  title =	 {A Tutorial-Style Introduction to DY*},
  booktitle =	 {Protocols, Logic, and Strands:
Essays Dedicated to Joshua Guttman on the Occasion of His 66.66 Birthday.},
  year =	 2021,
  publisher =	 {Springer},
  pages = {77--97},
  series = {LNCS},
  volume = {13066},
  abstract =	 {DY* is a recently proposed formal verification
                  framework for the symbolic security analysis of
                  cryptographic protocol code written in the F*
                  programming language.  Unlike automated symbolic
                  provers, D* accounts for advanced protocol features
                  like unbounded loops and mutable recursive data
                  structures as well as low-level implementation
                  details like protocol state machines and message
                  formats, which are often at the root of real-world
                  attacks. Protocols modeled in DY* can be executed,
                  and hence, tested, and they can even interoperate
                  with real-world counterparts.  DY* extends a long
                  line of research on using dependent type systems but
                  takes a fundamentally new approach by explicitly
                  modeling the global trace-based semantics within the
                  framework, hence bridging the gap between
                  trace-based and type-based protocol analyses. With
                  this, one can uniformly, precisely, and soundly
                  model, for the first time using dependent types,
                  long-lived mutable protocol state, equational
                  theories, fine-grained dynamic corruption, and
                  trace-based security properties like forward secrecy
                  and post-compromise security.

In this paper, we provide a tutorial-style introduction to DY*: We illustrate how to model and prove the security of the ISO-DH protocol, a simple key exchange protocol based on Diffie-Hellman.  },
}

@incollection{rfc8555,
  booktitle =  {Request for Comments},
  number =  8555,
  publisher ={IETF},
  url =     {https://datatracker.ietf.org/doc/html/rfc8555},
  author =  {Richard Barnes and Jacob Hoffman-Andrews and Daniel
             McCarney and James Kasten},
  title =   {{Automatic Certificate Management Environment (ACME)}},
  year =    2019,
  month =   mar,
  abstract = {Public Key Infrastructure using X.509 (PKIX) certificates are used
   for a number of purposes, the most significant of which is the
   authentication of domain names.  Thus, certification authorities
   (CAs) in the Web PKI are trusted to verify that an applicant for a
   certificate legitimately represents the domain name(s) in the
   certificate.  As of this writing, this verification is done through a
   collection of ad hoc mechanisms.  This document describes a protocol
   that a CA and an applicant can use to automate the process of
   verification and certificate issuance.  The protocol also provides
   facilities for other certificate management functions, such as
   certificate revocation.},
}

@article{acmeccs2021,
  ourwork     = {yes},
  author      = {Karthikeyan Bhargavan and Abhishek Bichhawat and Quoc Huy Do and Pedram Hosseyni and Ralf Küsters and Guido Schmitz and Tim Würtele},
  title	      = {An In-Depth Symbolic Security Analysis of the ACME Standard},
  booktitle   = {CCS '21: ACM Conference on Computer and Communications Security,
  November 14--19, 2021, Seoul, South Korea},
  year	      = 2021,
  publisher   = {ACM},
  note	      = {},
  abstract = {The ACME certificate issuance and management protocol, standardized as IETF RFC 8555, is an essential element of the web public key infrastructure (PKI). It has been used by Let's Encrypt and other certification authorities to issue over a billion certificates, and a majority of HTTPS connections are now secured with certificates issued through ACME. Despite its importance, however, the security of ACME has not been studied at the same level of depth as other protocol standards like TLS 1.3 or OAuth. Prior formal analyses of ACME only considered the cryptographic core of early draft versions of ACME, ignoring many security-critical low-level details that play a major role in the 100 page RFC, such as recursive data structures, long-running sessions with asynchronous sub-protocols, and the issuance for certificates that cover multiple domains.We present the first in-depth formal security analysis of the ACME standard. Our model of ACME is executable and comprehensive, with a level of detail that lets our ACME client interoperate with other ACME servers. We prove the security of this model using a recent symbolic protocol analysis framework called DY⋆, which in turn is based on the F⋆ programming language. Our analysis accounts for all prior attacks on ACME in the literature, including both cryptographic attacks and low-level attacks on stateful protocol execution. To analyze ACME, we extend DY* with authenticated channels, key substitution attacks, and a concrete execution framework, which are of independent interest. Our security analysis of ACME totaling over 16,000 lines of code is one of the largest proof developments for a cryptographic protocol standard in the literature, and it serves to provide formal security assurances for a crucial component of web security.},
}


@article{dystareurosp2021,
  ourwork     = {yes},
    author = {Karthikeyan Bhargavan and Abhishek Bichhawat and Quoc Huy Do and Pedram Hosseyni and Ralf Küsters and Guido Schmitz and Tim Würtele},
  title = {{DY*: A Modular Symbolic Verification Framework for Executable Cryptographic Protocol Code}},
  booktitle = {{2021 IEEE European Symposium on Security and Privacy (EuroS{\&}P)}},
  year = 2021,
  publisher   = {IEEE Computer Society},
  pages = {523--542},
  abstract = {We present DY\*, a new formal verification framework for the symbolic security analysis of cryptographic protocol code written in the F* programming language. Unlike automated symbolic provers, our framework accounts for advanced protocol features like unbounded loops and mutable recursive data structures, as well as low-level implementation details like protocol state machines and message formats, which are often at the root of real-world attacks.

Our work extends a long line of research on using dependent type systems for this task, but takes a fundamentally new approach by explicitly modeling the global trace-based semantics within the framework, hence bridging the gap between trace-based and type-based protocol analyses. This approach enables us to uniformly, precisely, and soundly model, for the first time using dependent types, long-lived mutable protocol state, equational theories, fine-grained dynamic corruption, and trace-based security properties like forward secrecy and post-compromise security.

DY* is built as a library of F* modules that includes a model of low-level protocol execution, a Dolev-Yao symbolic attacker, and generic security abstractions and lemmas, all verified using F*. The library exposes a high-level API that facilitates succinct security proofs for protocol code. We demonstrate the effectiveness of this approach through a detailed symbolic security analysis of the Signal protocol that is based on an interoperable implementation of the protocol from prior work, and is the first mechanized proof of Signal to account for forward and post-compromise security over an unbounded number of protocol rounds.},
}
